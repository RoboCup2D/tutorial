<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RoboCup2D Tutorial: Dynamic Positioning</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RoboCup2D Tutorial
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_sections_dynamic-positioning.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dynamic Positioning </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Nessa seção é descrito o sistema de formação SBSP (<em>Situation Based Strategic Positioning</em> ou em português algo como Posicionamento Estratégico Baseado na Situação). Nesse SBSP, cada player agent não é considerado no movimento dos outros jogadores e para a posição-alvo do movimento é considerada como entrada somente a posição da bola. Isto é feito para apenas parecer que não é um posicionamento cooperativo, e sim como em uma coordenação aparentemente individual. O comportamento de posicionamento descrito nesta seção é algo próximo às habilidades individuais de cada player agent. No entanto, uma vez que são necessários ajustes em consideração ao equilíbrio de toda a equipe na implementação da operação, o que se segue aqui é uma parte da seção Desenvolvimento da Equipe.</p>
<h3>Marcando o jogador adversário</h3>
<p>A marcação próxima a um adversário específico é necessária quando o time está em seu campo de defesa. Obviamente, essa operação pode ser feita em outras situações, mas isso pode acarretar em um uso excessivo de stamina do jogador. Porém, isto necessariamente não leva à uma situação perigosa de jogo que poderia atrapalhar a formação do time. Estando no campo adversário e sem bola, uma marcação à distância já é suficiente. Com a posse de bola, uma marcação no campo de defesa pode trazer problemas ao tentar receber a bola em um passe; porém, no seu campo de ataque e estando sem a bola, isto será o objetivo principal desse comportamento. Para conseguir isto, mais do que marcar o adversário desejado é necessário mover-se próximo à posição da bola. Antes de decidir a posição-alvo do movimento de marcação, primeiro é necessário determinar qual jogador adversário será marcado. No código a seguir, decide-se qual jogador adversário será o candidato:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> PlayerObject * getMarkTarget( <span class="keyword">const</span> WorldModel &amp; wm, <span class="keyword">const</span> Vector2D &amp; home_pos ) </div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> dist_opp_to_home = 1000.0;</div><div class="line">    <span class="keyword">const</span> PlayerObject * opp = wm.getOpponentNearestTo( M_home_pos, 1, &amp;dist_opp_to_home );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( ! opp || ( wm.existKickableTeamamte() &amp;&amp; opp-&gt;distFromBall() &gt; 2.5 ) ) {</div><div class="line">        <span class="keywordflow">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> ( dist_opp_to_home &gt; 7.0 &amp;&amp; home_pos.x &lt; opp-&gt;pos().x ) {</div><div class="line">        <span class="keywordflow">return</span> NULL;</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> PlayerPtrCont::const_iterator</div><div class="line">    end = wm.getTeammatesFromSelf().end();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> ( PlayerPtrCont::const_iterator it = wm.getTeammatesFromSelf().begin(); it != end; ++it ) {</div><div class="line">        <span class="keywordflow">if</span> ( (*it)-&gt;pos().dist( opp-&gt;pos() ) &lt; dist_opp_to_home ) {</div><div class="line">            <span class="keywordflow">return</span> NULL;</div><div class="line">            }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> opp;</div><div class="line">}</div></div><!-- fragment --><p>O código acima determina a posição para onde o player agent deve realizar o movimento de marcação sobre o adversário que, consequentemente, torna-se o jogador-alvo (target player).</p>
<p>Obtendo-se um ponteiro para o PlayerObject do adversário no método getMarkTarget, uma última modificação na coordenada Y é necessária para retroceder sem precisar de nenhuma rotação extra. Aqui, utiliza-se o valor da posição Y do próprio agent player, mas você pode utilizar um valor fixo.</p>
<div class="fragment"><div class="line">AngleDeg block_angle = ( wm.ball().pos() - opp-&gt;pos() ).th();</div><div class="line">Vector2D block_point = opp-&gt;pos() + Vector2D::polar2vector( 0.2, block_angle );</div><div class="line">block_point.x -= 0.1;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( block_point.x &lt; wm.self().pos().x - 1.5 ) {</div><div class="line">    block_point.y = wm.self().pos().y;</div><div class="line">}</div></div><!-- fragment --><p>No trecho de código acima, o objetivo é marcar o adversário próximo à home position do player agent. Numa visão mais abrangente onde se deseja um equilíbrio entre a função de cada jogador, a formação do time e os outros companheiros de equipe, seria necessária uma marcação mais complexa. Porém, em se tratando apenas de elaboração de regras, marcar o adversário parecer ser um tanto quanto difícil, particularmente, quando informações para identificação de outros jogadores são insuficientes. Portanto, para conseguir um comportamento de marcação mais confiável, compartilhar informações através de comunicação entre os jogadores é essencial.</p>
<h3>Bloquear a linha de passe</h3>
<p>Bloquear a linha de passe é uma importante tática defensiva pois reduz-se as opções do time adversário. Porém, como o jogador que está com a bola toma a iniciativa da jogada, o path behaviour não permite que o path course seja bem bloqueado mesmo se um player agent com características bem balanceadas for utilizado para tentar o bloqueio. Além disso, como a bola se move rapidamente, nem sempre é necessário tentar bloquear a linha de passe pois será difícil acompanhar o movimento da bola. Consequentemente, semelhante ao comportamento de marcação, é melhor tentar bloquear a linha de passe em situações defensivas onde o time está em seu campo de defesa.</p>
<p>O código a seguir mostra como bloquear a linha de passe da frente do gol até a direção do escanteio.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> BallObject &amp; ball = agent-&gt;world().ball();</div><div class="line">Vector2D center( -41.5, 0.0 );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( ball.pos().x &lt; -45.0 ) {</div><div class="line">    center.x = std::max( -48.0, ball.pos().x + 1.0 );</div><div class="line">}</div><div class="line"></div><div class="line">Line2D block_line( wm.ball().pos(), ( center - wm.ball().pos() ).th() );</div><div class="line">Vector2D block_point;</div><div class="line">block_point.y = std::max( 15.0, ball.pos().absY() - 10.0 );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( ball.pos().y &lt; 0.0 ) block_point.y *= -1.0;</div><div class="line">block_point.x = block_line.getX( block_point.y );</div></div><!-- fragment --><p>No exemplo acima, o player agent foi designado a mover-se em uma linha reta estabelecida entre uma posição fixa na frente do centro do gol e a posição da bola. Á 10m da bola, a distância mínima do eixo Y é 15m da coordenada Y da posição de bloqueio (block_point). Note que a role do jogador deve adotar outras regras quando o valor da coordenada Y da posição da bola é 15m ou menos. A coordenada X pode ser calculada a partir da equação da reta e o valor da coordenada Y. Essa implementação não pode ser considerada ótima pois nela é usado um número mágico, assim como em implementações similares a esta.</p>
<p>Se você deseja bloquear a linha de passe de jogadores adversários em particular, o player agent deve se mover na linha reta que conecta o adversário e a bola. Porém, a posição-alvo do movimento irá mudar durante os ciclos considerando que a bola e o adversário irão se mover. Durante o bloqueio, determinar se a posição do movimento é boa de uma forma fixa trará mais resultados do que apenas tentar bloquear uma linha reta qualquer do passe.</p>
<h3>Marcação na frente do adversário</h3>
<p>Imagine uma situação onde o jogador adversário inica um drible. Você não pode simplesmente correr atrás dele e tentar roubar a bola executando um behaviour para interceptar o drible. Nesse caso, é necessário que haja uma marcação na frente do adversário.</p>
<p>Segue o código:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> WorldModel &amp; wm = agent-&gt;world();</div><div class="line"><span class="keyword">const</span> PlayerObject * opp = wm.interceptTable()-&gt;fastestOpponent();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( ! opp ) {</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line">Vector2D block_point = opp-&gt;pos();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( wm.self().pos().x &gt; opp-&gt;pos().x ) {</div><div class="line">    block_point.x -= 5.0;</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    block_point.x -= 2.0;</div><div class="line">}</div><div class="line"></div><div class="line">Body_GoToPoint( block_point,</div><div class="line">     1.0, <span class="comment">// 1m para o erro da distância</span></div><div class="line">     ServerParam::i().maxPower(),</div><div class="line">     5, <span class="comment">// de modo a atingir a posição de destino depois de cinco ciclos</span></div><div class="line">     <span class="keyword">false</span>, <span class="comment">// não usar dash para trás</span></div><div class="line">     <span class="keyword">true</span>, <span class="comment">// não consumir recover</span></div><div class="line">     40.0 <span class="comment">//  permitir até 40 graus de erro de direção </span></div><div class="line">).execute( agent );</div></div><!-- fragment --><p>Você deve estar imaginando que o código acima para obter a posição-alvo é bem simples. De fato, é bem simples. Contudo, a intenção não é ir exatamente no ponto onde previu-se o movimento do jogador adversário. Além do mais, o código acima pode resultar em rotações desnecessárias quando elaborado apenas para um ponto. Para resolver isto, basta atribuir um valor de erro maior no método BodyGoToPoint. Como resultado, é possível reduzir as rotações desnecessárias apenas mudando um pouco a direção da posição-alvo.</p>
<p>Prever o comportamento do adversário pode ser mais eficaz quando executado pelos jogadores ofensivos.</p>
<h3>Movimento para cancelar a marcação</h3>
<ol type="1">
<li>Busca dinâmica</li>
</ol>
<p>Existem vários métodos para calcular o campo potencial como uma forma de mudar a posição do movimento. O código a seguir obtém a densidade do jogador em uma certa posição.</p>
<div class="fragment"><div class="line">Vector2D target_point( 45.0, 0.0 );</div><div class="line"><span class="keywordtype">double</span> congestion = 0.0;</div><div class="line"><span class="keyword">const</span> PlayerPtrCont::const_iterator end = agent-&gt;world().getOpponentsFromSelf().end();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> ( PlayerPtrCont::const_iterator o = agent-&gt;world().getOpponentsFromSelf().begin(); o != opps_end; ++o ) {</div><div class="line">    congestion += 1.0 / (*o)-&gt;pos().dist2( target_point );</div><div class="line">}</div></div><!-- fragment --><p>No exemplo acima, é obtida a densidade de congestão dos jogadores adversários em um ponto específico (target_point). A posição que o valor da congestão possui é minimizado de acordo com o cálculo de várias coordenadas de posições medidas a partir do target_point.</p>
<p>Tudo parece ótimo nessa algoritmo, mas não funciona nesse caso. O campo de visão do player agent é limitado e desde que cada jogador está se movendo, as posições-alvo (target position) dos jogadores adversários estão constantemente mudando. Nesse caso, operações de rotaçãoes incluíram vários movimentos do player agent e isto não seria nada eficiente.</p>
<p>Uma solução para isto é registrar a intenção de movimento do tempo limite em uma forma que continue a realizar operações de movimentação para a posição, assim em um certo período de tempo você pode decidir qual target position será escolhida de acordo com o tempo considerado.</p>
<p>No entanto, mesmo reduzindo movimentos utilizando intention, mudanças dinâmicas da posição-alvo que está em movimento parece não surtir muito efeito. Se você deseja um efeito mais confiável, é melhor usar um método que incorpore regras estáticas que serão descritos abaixo.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> WorldModel &amp; wm = agent-&gt;world();</div><div class="line">Vector2D target_point = home_pos;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( wm.ball().pos().y * wm.self().pos().y &lt; 0.0 &amp;&amp; wm.ball().pos().x &gt; 40.0 </div><div class="line">       &amp;&amp; 6.0 &lt; wm.ball().pos().absY() &amp;&amp; wm.ball().pos().absY() &lt; 17.0 ) {</div><div class="line"></div><div class="line">    Rect2D goal_area( Vector2D( 52.5 - 8.0, -6.0 ),</div><div class="line">    Vector2D( 52.5, 6.0 ) );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( ! wm.existTeammateIn( goal_area, 10, <span class="keyword">true</span> ) ) {</div><div class="line">        target_point.x = wm.ball().pos().x + 2.0;</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> ( target_point.x &gt; wm.getOffsideLineX() - 1.0 ) {</div><div class="line">            target_point.x = wm.getOffsideLineX() - 1.0;</div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="keywordflow">if</span> ( target_point.x &gt; 49.0 ) target_point.x = 49.0;</div><div class="line">        target_point.y = -1.0;</div><div class="line">        <span class="keywordflow">if</span> ( wm.ball().pos().y &gt; 0.0 ) target_point.y *= -1.0;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Você também pode realizar a operação para cancelar a marcação através de regras de posicionamento fixo. Desta forma, é possível determinar a posição fixa do target point. Para ser mais preciso, isto não é um posicionamento dinâmico, isto é um posicionamento tático para uma situação local, como será explicado na mais detalhadamente na próxima seção. Por exemplo, no caso da role ForwardSide, o que você deve fazer é passar para a frente do gol para marcar o adversário de frente como mostrado no código a seguir.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> WorldModel &amp; wm = agent-&gt;world();</div><div class="line">Vector2D target_point = home_pos;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( wm.ball().pos().y * wm.self().pos().y &lt; 0.0 &amp;&amp; wm.ball().pos().x &gt; 40.0</div><div class="line">       &amp;&amp; 6.0 &lt; wm.ball().pos().absY() &amp;&amp; wm.ball().pos().absY() &lt; 17.0 ) {</div><div class="line"></div><div class="line">    Rect2D goal_area( Vector2D( 52.5 - 8.0, -6.0 ),</div><div class="line">    Vector2D( 52.5, 6.0 ) );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( ! wm.existTeammateIn( goal_area, 10, <span class="keyword">true</span> ) ) {</div><div class="line">        target_point.x = wm.ball().pos().x + 2.0;</div><div class="line">        <span class="keywordflow">if</span> ( target_point.x &gt; wm.getOffsideLineX() - 1.0 ) {</div><div class="line">            target_point.x = wm.getOffsideLineX() - 1.0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> ( target_point.x &gt; 49.0 ) target_point.x = 49.0;</div><div class="line">        target_point.y = -1.0;</div><div class="line">        <span class="keywordflow">if</span> ( wm.ball().pos().y &gt; 0.0 ) target_point.y *= -1.0;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Ajuste da orientação do corpo do player agent</h3>
<p>A melhor ideia durante o jogo é ajustar a orientação do corpo mesmo quando não há ação a ser feita, em particular, quando o jogador já atingiu a posição final do seu movimento. Para um jogador ofensivo, é suficiente apenas rodar o corpo para a direção da linha de gol adversário. Isso pode ser facilmente obtido com o código a seguir:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( ! Body_GoToPoint( target_point, dist_thr, dash_power).execute( agent ) ) {</div><div class="line">    Vector2D face_point( 100.0, wm.self().pos().y );</div><div class="line">    Body_TurnToPoint( face_point ).execute( agent );</div><div class="line">}</div></div><!-- fragment --><p> Além disso, é útil ajustar a posição através do rear dash sem precisar mudar a orientação do corpo quando um jogador com role de marcação mais agressiva tiver que se mover continuamente para a target position.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( wm.self().pos().x &gt; target_point.x + dist_thr*0.5 </div><div class="line">    &amp;&amp; std::fabs( wm.self().pos().x - target_point.x ) &lt; 3.0 &amp;&amp; wm.self().body().abs() &lt; 10.0 ) {</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> back_dash_power = wm.self().getSafetyDashPower( -dash_power );</div><div class="line">    agent-&gt;doDash( back_dash_power );</div><div class="line">}</div></div><!-- fragment --><p>Para um jogador com role defensiva, é necessário elaborar quase que um "comportamento racional" de interceptação. Por exemplo, no caso de uma role que faz uma linha defensiva a interceptação, considerando que é necessário o movimento que interfira o curso de movimento do jogador adversário de lado a lado, é mostrado no código a seguir:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( ! Body_GoToPoint( target_point, dist_thr, dash_power ).execute( agent ) ) {</div><div class="line">    Vector2D face_point( wm.self().pos().x, 0.0 );</div><div class="line">    face_point.y = ( wm.ball().pos().y &lt; wm.self().pos().y ? -40.0 : 40.0 );</div><div class="line">    Body_TurnToPoint( body_point ).execute( agent );</div><div class="line">}</div></div><!-- fragment --><p>Além disso, você precisará armazenar a direção perpendicular do corpo do player agent em relação à bola de modo que ficar fácil de lidar caso ela seja chutada de repente:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( ! Body_GoToPoint( target_point, dist_thr, dash_power ).execute( agent ) ) {</div><div class="line">    AngleDeg body_angle = wm.ball().angleFromSelf();</div><div class="line">   </div><div class="line">    <span class="keywordflow">if</span> ( body_angle.degree() &lt; 0.0 ) body_angle -= 90.0;</div><div class="line">    <span class="keywordflow">else</span> body_angle += 90.0;</div><div class="line">  </div><div class="line">    Vector2D face_point = wm.self().pos();</div><div class="line">    face_point += Vector2D::polar2vector( 10.0, body_angle );</div><div class="line">    Body_TurnToPoint( face_point ).execute( agent );</div><div class="line">}</div></div><!-- fragment --><p>Porém, você deve verificar a posição da bola em qualquer caso. Assim, a operação para ajustar a orientação do corpo deve ser executada somente quando for possível confirmar a posição da bola. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
